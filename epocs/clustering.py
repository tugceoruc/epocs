import json
import os

from multiprocessing import Pool
from os import listdir

import numpy as np
import pandas as pd
import tmap as tm
import tqdm

from faerun import Faerun
from scipy import spatial
from scipy.cluster.hierarchy import fcluster, linkage
from scipy.spatial.distance import squareform


class ClusterPockets:
    def __init__(
        self,
        linkage_method="single",
        pocket_embeddings_path="./pocket_embeddings/",
        save_distance_matrix=False,
        min_cluster_dist=1.0,
        max_cluster_dist=3.0,
        increment=0.2,
        clusters_path="./clusters/",
        tmp_folder="./tmp/",
        distance_matrix_path="./",
        representative_selection=True,
        num_processes=1,
        debugging_mode: bool = False,
    ):
        self.linkage_method = linkage_method
        self.pocket_embeddings_path = pocket_embeddings_path
        self.save_distance_matrix = save_distance_matrix
        self.thresholds = list(
            np.arange(min_cluster_dist, max_cluster_dist + increment, increment)
        )
        self.clusters_path = clusters_path
        self.distance_matrix_path = distance_matrix_path
        self.representative_selection = representative_selection
        self.tmp_folder = tmp_folder
        self.num_processes = num_processes
        self.debugging_mode = debugging_mode

    def write_labels(self, labels, pocket_names, outname):
        """
        Writes generated clusters into json file.

        labels: cluster labels generated by fcluster
        pocket_names: list of pocket names
        outname: output file directory for json to be saved.
        """

        labels_dic = {i: [] for i in range(min(labels) - 1, max(labels))}
        for one in range(min(labels), max(labels) + 1):
            for idx, label in enumerate(labels):
                if label == one:
                    labels_dic[one - 1].append(pocket_names[idx])
        with open(outname, "w") as fp:
            json.dump(labels_dic, fp, indent=2)

    def select_representatives(self, pockets):
        """
        Returns selected representtive pocket for each protein ID (i.e. pdbID).
        It runs clustering for individual proteins (with the same parameters as
        for the whole list with a lower distance threshold cutoff) and selects one pocket from each cluster.
        This avoids having redundant pockets (i.e. highly similar pockets for the same protein) in the final clusters.

        pockets: list of pockets to be clustered
        """
        print("Representatives are being selected for each protein.")
        all_identifiers = np.unique([one.split("_")[0] for one in pockets])
        selected = []
        for identifier in all_identifiers:
            prefixed = [
                filename
                for filename in os.listdir(self.pocket_embeddings_path)
                if filename.startswith(identifier)
            ]
            if len(prefixed) > 1:
                distance_scores = np.zeros((len(prefixed), len(prefixed)))
                for i in range(len(prefixed)):
                    pocket1 = self.pocket_embeddings_path + prefixed[i]
                    embedding1 = pd.read_pickle(pocket1)
                    for j in range(i + 1, len(prefixed)):
                        pocket2 = self.pocket_embeddings_path + prefixed[j]
                        embedding2 = pd.read_pickle(pocket2)
                        euclidean_dist = spatial.distance.euclidean(
                            embedding2, embedding1
                        )
                        distance_scores[i, j] = euclidean_dist
                        distance_scores[j, i] = euclidean_dist
                linkage_mat = linkage(
                    squareform(distance_scores), method=self.linkage_method
                )
                labels = fcluster(linkage_mat, criterion="distance", t=1.0)
                labels_unique = {one: [] for one in np.unique(labels)}
                for i in range(len(prefixed)):
                    labels_unique[labels[i]].append(prefixed[i])
                representatives = []
                for lb in labels_unique:
                    representatives.append(labels_unique[lb][0])
                selected.append(representatives)
            else:
                selected.append(prefixed)
        return [item for group in selected for item in group]

    def calculate_pairwise_distances(self, item):
        """
        Calculates pairwise distances for one pocket against all pockets
        and saves calculated distances to a json file.

        item: (pocket, pockets) where pocket is the pocket of interest,
                pockets is the list of all pockets.
        """
        (pocket, pockets) = item

        distance_dic = {}
        embedding1 = pd.read_pickle(self.pocket_embeddings_path + pocket)
        for j, onePocket in enumerate(pockets):
            embedding2 = pd.read_pickle(self.pocket_embeddings_path + pockets[j])
            euclidean_dist = spatial.distance.euclidean(embedding1, embedding2)
            distance_dic[onePocket] = euclidean_dist
        dic_path = self.tmp_folder + pocket.split(".")[0] + ".json"
        json.dump(distance_dic, open(dic_path, "w"))

    def obtain_distance_matrix(self, pockets):
        """
        Generates distance matrix for given pocket list:

        pockets: list of pockets

        """

        print("Pairwise distance calculation is starting...")
        items = [(pocket, pockets) for pocket in pockets]
        if self.num_processes == 1:
            for item in tqdm.tqdm(items):
                self.calculate_pairwise_distances(item)
        else:
            with Pool(processes=self.num_processes) as pool:
                list(
                    tqdm.tqdm(
                        pool.imap(self.calculate_pairwise_distances, items),
                        total=len(items),
                    )
                )

        print(f"Distance matrix is about to be generated for {len(pockets)} pockets.")
        distance_matrix = np.zeros((len(pockets), len(pockets)))
        for i, pocket in enumerate(pockets):
            pocket_dic = json.load(
                open(self.tmp_folder + pocket.split(".")[0] + ".json")
            )
            for j, pocket in enumerate(pockets):
                distance_matrix[i, j] = pocket_dic[pocket]
        print("Distance matrix is generated.")

        if self.save_distance_matrix or self.debugging_mode:
            np.savez(f"{self.tmp_folder}/distance_matrix.npz", distance_matrix)
            print("Distance matrix is saved.")

        return distance_matrix

    def modify_html(self, html_file):
        """
        Modifies generated .html file to read .js file from the pwd.

        """

        out = open(f"{html_file}_mod", "w")
        with open(html_file) as f:
            content = f.readlines()
            for aline in content:
                if "script src" in aline and "clusters" in aline:
                    js_path = aline.split('"')[1]
                    new_js_path = f"./{js_path.split('/')[-1]}"
                    aline = aline.replace(js_path, new_js_path)
                if "#selected #selected-container {" in aline:
                    aline = (
                        aline + "        height: 300px;\n        overflow-y: auto;  \n"
                    )
                out.write(aline)
        out.close()
        command = f"mv {html_file}_mod {html_file}"
        os.system(command)

    def plot_pocket_map(self, pockets, distance_matrix, cluster_file):
        """
        From the distance matrix, based on the clusters from cluster_file,
        it generates reduced distance matrix via calculating the distances
        between the clusters. From reduced distance matrix, tmap generates
        the 2D representation and faerun plots the interactive map.


        pockets: list of pockets
        distance_matrix: generated distance matrix
        cluster_file: cluster file path
        """

        pocket_map = {name: idx for idx, name in enumerate(pockets)}
        clusters = json.load(open(cluster_file))

        cluster_indx = {}
        for acluster in clusters:
            cluster_indx[acluster] = []
            for pocket in clusters[acluster]:
                cluster_indx[acluster].append(pocket_map[pocket])
        pocket_names = []
        cluster_size = []

        for cluster in clusters:
            cluster_size.append(len(clusters[cluster]))
            pocket_links = "__".join([one.split(".")[0] for one in clusters[cluster]])
            pocket_names.append(pocket_links)

        point_scale = np.log(cluster_size + np.ones(len(cluster_size)))
        point_scale = [np.round(one * 1.2, 1) for one in point_scale]
        min_matrix = np.zeros((len(clusters), len(clusters)))
        for i in cluster_indx:
            for j in cluster_indx:
                if i != j:
                    selected_values = [
                        [distance_matrix[m][n] for n in cluster_indx[j]]
                        for m in cluster_indx[i]
                    ]
                    selected_values = list(np.array(selected_values).flatten())
                    min_matrix[int(i), int(j)] = min_matrix[int(j), int(i)] = np.min(
                        selected_values
                    )
        # print(min_matrix)
        if self.debugging_mode:
            np.savez(
                f"{self.tmp_folder}/distance_matrix_reduced_{cluster_file.split('/')[-1]}.npz",
                min_matrix,
            )
            print(
                f"Cluster-cluster distance matrix for {cluster_file.split('/')[-1]} is saved."
            )
        # min_matrix = np.load(f"{self.tmp_folder}/distance_matrix_reduced_{cluster_file.split('/')[-1]}.npz")
        # min_matrix = distance_matrix["arr_0"].astype("float32")

        plot_labels = []
        for idx, pockets in enumerate(pocket_names):
            plot_labels.append(
                "__".join([f"cluster_{idx + 1} ({cluster_size[idx]} pockets)", pockets])
            )

        edge_list = []
        for i in range(len(min_matrix)):
            for j in range(i + 1, len(min_matrix)):
                edge_list.append([i, j, min_matrix[i, j]])

        n = len(min_matrix)
        x, y, s, t, _ = tm.layout_from_edge_list(n, edge_list, create_mst=True)

        faerun = Faerun(clear_color="#ffffff", view="front", coords=False)
        faerun.add_scatter(
            "pocket_clusters",
            {
                "x": x,
                "y": y,
                "labels": plot_labels,
                "c": cluster_size,
                "s": point_scale,
            },
            colormap=["viridis"],
            shader="smoothCircle",
            point_scale=6,
            max_point_size=10,
            has_legend=True,
            selected_labels=["Pocket list"],
            series_title=["Cluster size"],
        )
        faerun.add_tree(
            "Pocket_clusters_tree",
            {"from": s, "to": t},
            point_helper="pocket_clusters",
            color="#666666",
        )
        plt_name = f"{cluster_file[:-5]}"
        faerun.plot(plt_name)
        self.modify_html(f"{cluster_file[:-5]}.html")

    def get_clusters(self):
        """
        Generates the clusters based on the pocket representations in self.pocket_embeddings_path,
        and plots the map of the pockets.
        """

        pockets = listdir(self.pocket_embeddings_path)
        if self.representative_selection:
            pockets = self.select_representatives(pockets)

        distance_matrix = self.obtain_distance_matrix(pockets)
        # distance_matrix = np.load("./distance_matrix.npz")
        # distance_matrix = distance_matrix["arr_0"].astype("float32")

        linkage_mat = linkage(squareform(distance_matrix), method=self.linkage_method)
        for thr in self.thresholds:
            print(
                f"Clusters for threshold {np.round(thr, 3)} is about to be generated."
            )
            labels = fcluster(linkage_mat, criterion="distance", t=thr)
            cluster_file = f"{self.clusters_path}/clusters_thr{np.round(thr, 3)}.json"
            self.write_labels(
                labels,
                pockets,
                cluster_file,
            )
            self.plot_pocket_map(pockets, distance_matrix, cluster_file)

        print("Clusters are generated.")
